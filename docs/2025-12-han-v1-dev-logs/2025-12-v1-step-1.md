Yesss, letâ€™s code-gradient-descent together ğŸ§ªğŸ±â€ğŸ‘¤ Weâ€™ll keep each step *tiny* + tested.

Iâ€™ll do:

1.  A **mini plan flowchart** for the next few steps.
2.  **Step 1 only**: implement `core/messages.py` + its unit tests.

You can then paste & run, and we iterate.

------------------------------------------------------------------------

## Tiny plan flowchart (near-term steps)

``` text
Step 1  â”€â–º  core/messages.py
          - Message
          - EpisodeState
          - tests

Step 2  â”€â–º  core/episode.py
          - EpisodeRunner skeleton
          - tests (no real atoms yet)

Step 3  â”€â–º  agents/organism.py + agents/controller.py (skeletons)
          - tests: basic wiring

Step 4  â”€â–º  1â€“2 simple atoms + a toy task
          - first runnable episode
```

Right now: **Step 1 only**.

------------------------------------------------------------------------

## 1. Create basic folders (once)

From repo root (where `pyproject.toml` will live), create:

``` bash
mkdir -p han/core
mkdir -p tests/core
touch han/__init__.py
touch han/core/__init__.py
```

So structure (so far):

``` text
han/
  han/
    __init__.py
    core/
      __init__.py
  tests/
    core/
```

------------------------------------------------------------------------

## 2. Implement `core/messages.py`

**File:** `han/core/messages.py`

``` python
# han/core/messages.py

"""
Core data structures for information flow inside one episode.

- Message: one piece of information passed between components.
- EpisodeState: short-term memory & bookkeeping for a single task run.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass
class Message:
    """
    One atomic piece of information flowing through the HAN.

    Attributes
    ----------
    id:
        Integer index within this episode's message list.
        (0 for first message, 1 for second, etc.)
    sender:
        Name of the component that produced this message
        (e.g. "env", "planner", "coder", "tester").
    receiver:
        Name of the intended consumer, or None if not yet assigned
        or broadcast / generic.
    role:
        Semantic type of the message, e.g.
        "spec", "plan", "code", "critique", "test_result".
    content:
        The payload itself (commonly text or code, but can be anything).
    metadata:
        Arbitrary extra tags (timestamps, scores, tool info, etc.).
    """

    id: int
    sender: str
    receiver: Optional[str]
    role: str
    content: Any
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class EpisodeState:
    """
    Short-term memory & control flags for a single episode (one task run).

    Attributes
    ----------
    task_id:
        Identifier of the task being solved.
    messages:
        Full history of Message objects in this episode
        (in chronological creation order).
    step:
        Current step index (starts at 0, incremented by the engine).
    done:
        Whether the episode has terminated.
    info:
        Scratch space for metrics and helper values
        (e.g. tests_passed, tests_total, final_status, etc.).
    """

    task_id: str
    messages: List[Message] = field(default_factory=list)
    step: int = 0
    done: bool = False
    info: Dict[str, Any] = field(default_factory=dict)

    def add_message(
        self,
        sender: str,
        receiver: Optional[str],
        role: str,
        content: Any,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Message:
        """
        Create a new Message, append it to `messages`, and return it.

        - Assigns a fresh, consecutive `id` based on current message count.
        - If `metadata` is not provided, uses an empty dict.

        The engine (EpisodeRunner) and atoms will use this as the
        standard way to create messages, so all ids are consistent.
        """
        if metadata is None:
            metadata = {}

        new_id = len(self.messages)

        msg = Message(
            id=new_id,
            sender=sender,
            receiver=receiver,
            role=role,
            content=content,
            metadata=metadata,
        )
        self.messages.append(msg)
        return msg
```

This is deliberately simple:

-   IDs are just `len(self.messages)` when created.
-   No hidden counters, no cleverness. Minimal but sufficient.

------------------------------------------------------------------------

## 3. Unit tests for `core/messages.py`

Weâ€™ll use **pytest**. If you donâ€™t have it: `pip install pytest` (once).

**File:** `tests/core/test_messages.py`

``` python
# tests/core/test_messages.py

import pytest

from han.core.messages import Message, EpisodeState


def test_message_basic_fields():
    """Message should store provided fields as-is."""
    m = Message(
        id=3,
        sender="planner",
        receiver="coder",
        role="plan",
        content="Do X then Y",
        metadata={"temperature": 0.3},
    )

    assert m.id == 3
    assert m.sender == "planner"
    assert m.receiver == "coder"
    assert m.role == "plan"
    assert m.content == "Do X then Y"
    assert m.metadata["temperature"] == 0.3


def test_episode_state_defaults():
    """EpisodeState should initialize with sensible defaults."""
    state = EpisodeState(task_id="task-123")

    assert state.task_id == "task-123"
    assert state.step == 0
    assert state.done is False
    assert state.messages == []
    assert isinstance(state.info, dict)
    assert state.info == {}  # empty by default


def test_add_message_assigns_consecutive_ids():
    """
    add_message should append messages and assign consecutive ids
    starting from 0.
    """
    state = EpisodeState(task_id="t1")

    m1 = state.add_message(
        sender="env",
        receiver=None,
        role="spec",
        content="Write a function f.",
    )
    m2 = state.add_message(
        sender="planner",
        receiver="coder",
        role="plan",
        content="Plan: implement f using ...",
    )
    m3 = state.add_message(
        sender="coder",
        receiver=None,
        role="code",
        content="def f(x): return x + 1",
    )

    # ids should be 0, 1, 2
    assert m1.id == 0
    assert m2.id == 1
    assert m3.id == 2

    # messages should be stored in order
    assert state.messages == [m1, m2, m3]


def test_add_message_uses_empty_metadata_by_default():
    """If metadata is not passed, add_message should use an empty dict."""
    state = EpisodeState(task_id="t2")

    m = state.add_message(
        sender="env",
        receiver=None,
        role="spec",
        content="Just a spec.",
    )

    assert isinstance(m.metadata, dict)
    assert m.metadata == {}
```

------------------------------------------------------------------------

## 4. Run tests

From repo root:

``` bash
pytest
```

You should see something like:

``` text
==================== test session starts ====================
collected 4 items

tests/core/test_messages.py ....                      [100%]

===================== 4 passed in 0.XXs =====================
```

If anything fails, paste the error and weâ€™ll debug right away.

------------------------------------------------------------------------

## 5. Visual mental model for what we just built

``` text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EpisodeState               â”‚
â”‚  - task_id                  â”‚
â”‚  - messages  [Message...]   â”‚
â”‚  - step                     â”‚
â”‚  - done                     â”‚
â”‚  - info  {metrics,...}      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ add_message(...)
            v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Message                   â”‚
â”‚   - id                      â”‚
â”‚   - sender                  â”‚
â”‚   - receiver                â”‚
â”‚   - role                    â”‚
â”‚   - content                 â”‚
â”‚   - metadata                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Everything else (EpisodeRunner, HANOrganism, Controllerâ€¦) will build **on top of this**.

------------------------------------------------------------------------

If your tests pass, next step (in the *next* message) will be:

> **Step 2**: skeleton for `core/episode.py` (EpisodeRunner) with minimal unit tests that donâ€™t require real atoms yet.

You can tell me when `pytest` is green and weâ€™ll continue the ladder. â¤ï¸

------------------------------------------------------------------------

ğŸ“… *Last modified: `Thursday, December 11, 2025`*